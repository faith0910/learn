####                                                   阻塞队列

##### 1.ArrayBlockingQueue

ArrayBlockingQueue是典型的有界队列，内部是由数组存储元素的，利用ReentrantLock实现线程安全的（先进先出）。

```java
ArrayBlockingQueue(int capacity, boolean fair)
```

第一个参数是初始化容量，第二个参数是是否公平。正如ReentrantLock一样，如果ArrayBlockingQueue被设置为非公平的，那么就存在插队的可能；如果设置为公平的，那么等待了最长时间的线程会被优先处理，其它线程不允许插队，不过这样的公平策略会带来一定的性能损耗，因为非公平的吞吐量通常高于公平的情况。

##### 2.LinkedBlockingQueue

LinkedBlockingQueue是一个内部由链表实现的BlockingQueue，如果我们不指定它的初始容量，那么它的容量默认就为整型的最大值Integer.MAX_VALUE，由于这个值非常大，我们不可能放入这么多。所以它被称为无界队列，代表它几乎没有界限（先进先出）。

##### 3.SynchronousQueue

<img src="/Users/guanghui/Documents/personal/xunan/Cgq2xl4lhhSAZIuZAABMMZW2RVk163.png" alt="img" style="zoom:67%;" />

SynchronousQueue 最大的不同之处在于，它的容量为 0，所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，知道有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取。

SynchronousQueue的容量是1而不是0，因为SynchronousQueue不需要去持有元素，它所做的事情就是直接传递，由于每当需要传递的时候，SynchronousQueue会把数据直接由生产者传给消费者，在此期间不需要做存储，运用得当，效率很高的。

由于它的容量为 0，所以相比于一般的阻塞队列，SynchronousQueue 的很多方法的实现是很有意思的，我们来举几个例子：

```java
public E peek() {
    return null;
}
```

因为peek方法是取出头结点，但是SynchronousQueue的容量是0，所以连头结点都没有，peek方法也就没有意义，所以始终返回null。同理，element 始终会抛出 NoSuchElementException 异常。

##### 4.PriorityBlockingQueue

PriorityBlockingQueue是一个支持优先级的无界阻塞队列，可以通过自定义类实现compareto()方法来指定队列元素的排序规则，或者是初始化的时候通过构造器参数Comparator 来知道排序规则。同时，插入队列的元素必须是比较大小的，也就是 Comparable 的，否则会抛出 ClassCastException 异常。

它的take方法在队列为空时会阻塞，但是正是由于它是无界队列，而且会自动扩容，所以它的队列永远不会满，所以它的put方法永远不会阻塞，添加操作永远会成功，也由于如此，它的成员变量只有一个Condition：

```java
private final Condition notEmpty;
```

这和之前的 ArrayBlockingQueue 拥有两个 Condition（分别是 notEmpty 和 notFull）形成了鲜明的对比，我们的 PriorityBlockingQueue 不需要 notFull，因为它永远都不会满，真是“有空间就可以任性”。

##### 5.DelayQueue

DelayQueue这个队列有点特殊，它具有"延迟"的功能，我们可以设定让队列里的任务延迟多久之后执行，它是无界队列，放入的元素必须实现Delayed接口，而 Delayed 接口又继承了 Comparable 接口，所以自然就拥有了比较和排序的能力，代码如下：

```java
public interface Delayed extends Comparable<Delayed> {
    long getDelay(TimeUnit unit);
}
```

可以看出这个 Delayed 接口继承自 Comparable，里面有一个需要实现的方法，就是  getDelay。这里的 getDelay 方法返回的是“还剩下多长的延迟时间才会被执行”，如果返回 0 或者负数则代表任务已过期。

元素会根据延迟时间长短被放入到队列的不同位置，越靠近队列头代表越早期。

DelayQueue 内部使用了 PriorityQueue 的能力来进行排序。

#### 阻塞和非阻塞队列的并发安全原理

##### ArrayBlockingQueue 源码分析

```java
// 用于存放元素的数组
final Object[] items;
// 下一次读取操作的位置
int takeIndex;
// 下一次写入操作的位置
int putIndex;
// 队列中的元素数量
int count;
```

第一个最核心的、用于存储元素的Object类型数组，然后它还有两个位置变量，分别是takeindex和putindex；另外用一个count来计数，它所记录的就是队列中元素的个数。

另外，我们再来看下面这三个变量：

```java
// 以下3个是控制并发用的工具
final ReentrantLock lock;
private final Condition notEmpty;
private final Condition notFull;
```

这三个变量也非常关键，第一个就是一个 ReentrantLock，而下面两个 Condition 分别是由 ReentrantLock 产生出来的，这三个变量就是我们实现线程安全最核心的工具。

ArrayBlockingQueue实现并发同步的原理就是利用ReentrantLock和它的两个Condition，读操作和写操作都需要先获取到ReentrantLock独占锁才能进行下一步操作。进行读操作时如果队列为空，线程就会进入到读线程专属的notEmpty的Condition队列中去排队，等待写线程写入新的元素；同理，如果队列已满，这个时候写操作的线程会进入到写线程专属的notNull的Condition队列中去排队，等待读线程将队列元素移出并腾出空间。

和 ArrayBlockingQueue 类似，其他各种阻塞队列如 LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue、DelayedWorkQueue 等一系列 BlockingQueue 的内部也是利用了 ReentrantLock 来保证线程安全，只不过细节有差异，比如 LinkedBlockingQueue 的内部有两把锁，分别锁住队列的头和尾，比共用同一把锁的效率更高，不过总体思想都是类似的。

##### 非阻塞队列ConcurrentLinkedQueue

ConcurrentLinkedQueue 是使用链表作为其数据结构的，看它的关键方法：

```java
public boolean offer(E e) {
    checkNotNull(e);
    final Node<E> newNode = new Node<E>(e);

    for (Node<E> t = tail, p = t;;) {
        Node<E> q = p.next;
        if (q == null) {
            // p is last node
            if (p.casNext(null, newNode)) {
                // Successful CAS is the linearization point
                // for e to become an element of this queue,
                // and for newNode to become "live".
                if (p != t) // hop two nodes at a time
                    casTail(t, newNode);  // Failure is OK.
                return true;
            }
            // Lost CAS race to another thread; re-read next
        }
        else if (p == q)
            // We have fallen off list.  If tail is unchanged, it
            // will also be off-list, in which case we need to
            // jump to head, from which all live nodes are always
            // reachable.  Else the new tail is a better bet.
            p = (t != (t = tail)) ? t : head;
        else
            // Check for tail updates after two hops.
            p = (p != t && t != (t = tail)) ? t : q;
    }
}

```

在检查完空判断之后，可以看到它整个是一个大的 for 循环，而且是一个非常明显的死循环。在这个循环中有一个非常亮眼的 p.casNext 方法，这个方法正是利用了 CAS 来操作的，而且这个死循环去配合 CAS 也就是典型的乐观锁的思想。我们就来看一下 p.casNext 方法的具体实现，其方法代码如下：

```java
boolean casNext(Node<E> cmp, Node<E> val) {
    return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
}
```

可以看出这里运用了 UNSAFE.compareAndSwapObject 方法来完成 CAS 操作，而 compareAndSwapObject 是一个 native 方法，最终会利用 CPU 的 CAS 指令保证其不可中断。

可以看出，非阻塞队列 ConcurrentLinkedQueue 使用 CAS 非阻塞算法 + 不停重试，来实现线程安全，适合用在不需要阻塞功能，且并发不是特别剧烈的场景。