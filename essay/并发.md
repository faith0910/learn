#### 1.线程的优势

1.发挥处理器的强大能力

2.建模的简单性

3.异步事件的简化处理

4.响应更灵敏的用户界面

#### 2.1线程安全性

在线程安全性的定义中，最核心的概念是正确性。

正确性的含义是：某个类的行为与其规范完全一致。

要编写线程安全的代码，核心在于对状态访问操作进行管理，特别是共享的和可变的状态。

#### 2.2原子性

##### 		2.2.1 竞态条件

要获取正确的结果，必须取决于事件发生的顺序。

竞态条件的本质---基于一种可能失效的观察结果做出判断或执行某个计算，这种类型的竞态条件称为"先检查后执行"。先观察到某个条件为真，然后根据这个观察结果做出相应的动作。

使用"先检查后执行"的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际使用时才进行，同时要确保只被初始化一次。

##### 		2.2.2复合操作

要避免竞态条件问题，就必须在某个线程修改变量时，通过某种方式防止其它线程使用这个变量，从而确保其它线程只能在修改操作完成之前或者之后读取和修改状态，而非在修改状态的过程中。

"读取---修改---写入"统称为复合操作。

#### 2.3加锁机制

##### 		2.3.1内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块。同步代码块包括两部分：一个作为锁对象的引用，一个作为由这个锁保护的代码块。

每个JAVA对象都可以用作一个实现同步的锁，这些锁被称为内置锁或者监视器锁。线程在进入同步代码块就会自动获取锁，并且在退出同步代码块的时候自动释放锁，而无论是通过正常的控制路径的退出，还是在同步代码块中抛出异常退出。获取内置锁的唯一途径就是进入由这个锁保护的同步代码块或者方法。

##### 		2.3.2重入

当某个线程请求一个由其它线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获取一个由他自己持有的锁时，那么这个请求就会成功。"重入"意味着获取锁的操作的粒度时"线程"，而不是"调用"。

重入的一种实现方法是：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记录下锁的持有者，并且将计数值置为1。如果一个线程再次获取这个锁时，计数值将递增，而当线程退出同步代码块的时候，计时器就会相应的递减。当计数器为0时，这个锁被释放。

重入进一步提升了加锁行为的封装性，简化了面向对象并发代码的开发。



