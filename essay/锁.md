### 										JAVA中常见的锁有哪些？

根据分类标准，我们把锁分为7大类别：

​		偏向锁/轻量级锁/重量级锁	

​		可重入锁/不可重入锁

​		共享锁/独占锁

​		公平锁/非公平锁	

​		悲观锁/乐观锁

​		自旋锁/非自旋锁

​		可中断锁/不可中断锁

**a.<u>偏向锁/轻量级锁/重量级锁**</u>(特指的是synchronized锁的三种状态，通过对象头的mark word来表明锁的状态)

​		偏向锁：如果自始至终，对于这把锁都不存在竞争，那么其实就没有必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化之后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当第一个线程来访问它并尝试获取锁时，它就将这个线程记录下来，以后如果尝试获取所的线程正是偏向锁的拥有者，就可以直接获取锁，开销很小，性能最好。

​		轻量级锁：jvm开发者发现很多情况下，synchronized中的代码是被多个线程交替执行的，而不是同时执行的，也就是说不存在实际的竞争，或者只有短时间的锁竞争，用CAS就可以解决，这种情况下，用完全互斥的重量级锁是没有必要的。轻量级锁指的是当锁原来是偏向锁时，被另一个线程访问，说明存在竞争,那么偏向锁就会升级为轻量级锁，线程会通过自旋的方式来尝试获取锁，而不会陷入阻塞。

​		重量级锁：重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程存在实际竞争时，且竞争时间比较长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其它申请却拿不到锁的线程进入阻塞状态。

​		你可以发现锁的升级路径：无锁---偏向锁---轻量级锁---重量级锁

​		综上所述，偏向锁的性能最好，可以避免CAS操作。而轻量级锁利用自旋和CAS避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁会把获取不到锁的线程阻塞，性能最差。

**b.**<u>**可重入锁/不可重入锁**<u>

​		可重入锁是指当前线程已经拥有这把锁了，能在不释放这把锁的情况下继续获取锁；同理不可重入锁就是指的是虽然当前线程持有了这把锁，但是如果想再次获取这把锁，也必须要释放了锁之后才可以再次尝试获取。

​		对于可重入锁而言，最典型的就是ReentrantLock了，正如它的名字一样，reentrant就是可重入的意思，它也是Lock接口的一个实现类。

**c.<u>共享锁/独占锁<u>**		

​		共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同事被一个线程获得。读写锁就很好的诠释了共享锁和独占锁的理念。读写锁中的读锁就是共享锁，而写锁是独占锁。读锁可以被同时被多个线程锁持有，而写锁最多只能同时被一个线程所持有。

**d.<u>公平锁/非公平锁<u>**

​		公平锁的含义在于如果线程拿不到这把锁，那么线程就会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么"完美"了，他会在一定的情况下，忽略到已经排队的线程，产生插队现象。

**e.<u>悲观锁/乐观锁<u>**

​		悲观锁的概念是，在获取资源之前必须要拿到锁，以便达到"独占"的状态，当前线程在操作资源的时候，其它线程由于拿不到锁，所以不能来影响我。而乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反乐观锁利用CAS理念，在不独占资源的情况下，完成了对资源的修改。

**f.<u>自旋锁/非自旋锁<u>**

​		自旋锁的理念是当前线程现在拿不到锁，并不直接陷入阻塞或者释放CPU资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象的比喻成"自旋"，就像是线程在进行"自我旋转"。相反，非自旋锁的理念是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其它的处理逻辑，去排队，陷入阻塞等等。

**g.<u>可中断锁/不可中断锁<u>**

​		在Java中，被synchronized关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路，必须拿到锁之后才能就行其它逻辑处理。而我们的ReentrantLock是一种典型的可中断锁，例如使用lockinterruptibly方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他事情，不需要一直等到获取锁之后才离开。

### 悲观锁和乐观锁的本质是什么？

a.悲观锁比较悲观，认为写的情况多，遇到并发写的可能性高，每次别人操作数据的时候都认为别人会修改，所以在读写数据的时候都会上锁，这样其它线程就无法访问修稿数据，确保数据的内容万无一失。

java中的悲观锁就是synchronized，AQS框架下的锁一般都是cas乐观锁去获取锁，获取不到才会转换为悲观锁，如RerntrantLock。

b.乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去操作数据的时候都认为别人不会修改，所以不会上锁，不会不让别的线程来接触它，同时，为了确保数据的正确性，在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。 java中的乐观锁基本都是基于CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟预期值是否一样，一样则更新，否则失败。

java中的乐观锁典型案例就是原子类。

数据库中同时拥有悲观锁和乐观锁的思想。例如我们在MySQL中选择select for update语句，那就是悲观锁，再提交之前不允许第三方来修改该数据，这样会造成一定的性能损耗，在高并发情况下是不可取的。

```mysql
select status from t_goods where id=1 for update;
```

相反我们可以用一个版本字段version在数据库中实现乐观锁。在获取及修改数据时都不需要加锁，但是我们在获取完数据并计算完毕，准备更新数据时，会检查版本号跟获取数据时的版本号是否一致，如果一致就直接更新。否则则说明在计算期间已经有其他数据更改过这个数据了，所以会放弃修改数据，并选择重试。

```sql
update student set name = '张珊' version =2 where id = 100 and version = 1
	
```

两种锁的实用场景

悲观锁适用于并发写入多。临界区代码复杂。竞争激烈等场景，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗。

乐观锁适用于大部分是读取，少部分时修改的场景，也适合读写都很多，但是并发不激烈的场景。在这些场景下，乐观锁不加锁的特点可以大幅提高性能。

### 如何看到 synchronized 背后的“monitor 锁”？

我们都知道，最简单的同步方式就是利用 synchronized 关键字来修饰代码块或者修饰一个方法，那么这部分被保护的代码，在同一时刻就最多只有一个线程可以运行，而synchronized背后就是利用monitor锁实现的。所以首先我们来看下获取和释放 monitor 锁的时机，每个 Java 对象都可以用作一个实现同步的锁，这个锁被称为内置锁或者monitor锁，获得 monitor 锁的唯一途径就是进入由这个锁保护的同步代码块或同步方法，线程在进入被synchronized修饰的代码块之前会自动获取锁，并且无论是正常路径退出，还是通过抛出异常退出，在退出的时候都会自动释放锁。

我们来看个synchronized 修饰方法的代码的例子：

```java
public synchronized void method() {
    method body
}
```

我们看到 method() 方法是被 synchronized 修饰的，为了方便理解其背后的原理，我们把上面这段代码改写为下面这种等价形式的伪代码。

```java
public void method() {
    this.intrinsicLock.lock();
    try{
        method body
    }
    finally {
        this.intrinsicLock.unlock();
    }
}
```

在这种写法中，进入 method 方法后，立刻添加内置锁，并且用 try 代码块把方法保护起来，最后用 finally 释放这把锁，这里的 intrinsicLock 就是 monitor 锁。经过这样的伪代码展开之后，相信你对 synchronized 的理解就更加清晰了。

###### 用 javap 命令查看反汇编的结果

JVM 实现 synchronized 方法和 synchronized 代码块的细节是不一样的，下面我们就分别来看一下两者的实现。

<u>同步代码块</u>

首先我们来看下同步代码块的实现，如代码所示

```java
public class SynTest {
    public void synBlock() {
        synchronized (this) {
            System.out.println("lagou");
        }
    }
}
```

在 SynTest 类中的 synBlock 方法，包含一个同步代码块，synchronized 代码块中有一行代码打印了 lagou 字符串，下面我们来通过命令看下 synchronized 关键字到底做了什么事情：首先用 cd 命令切换到 SynTest.java 类所在的路径，然后执行 javac SynTest.java，于是就会产生一个名为 SynTest.class 的字节码文件，然后我们执行 javap -verbose SynTest.class，就可以看到对应的反汇编内容。

关键信息如下：

```java
  public void synBlock();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         3: monitorenter
         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: ldc           #3                      // String lagou
         9: invokevirtual #4               // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        12: aload_1
        13: monitorexit
        14: goto          22
        17: astore_2
        18: aload_1
        19: monitorexit
        20: aload_2
        21: athrow
        22: return
```

从里面可以看出，synchronized 代码块实际上多了 monitorenter 和 monitorexit 指令，标红的第3、13、19行指令分别对应的是 monitorenter 和 monitorexit。这里有一个 monitorenter，却有两个 monitorexit 指令的原因是，JVM 要保证每个 monitorenter 必须有与之对应的 monitorexit，monitorenter 指令被插入到同步代码块的开始位置，而 monitorexit 需要插入到方法正常结束处和异常处两个地方，这样就可以保证抛异常的情况下也能释放锁

可以把执行 monitorenter 理解为加锁，执行 monitorexit 理解为释放锁，每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为 0，我们来具体看一下 monitorenter 和 monitorexit 的含义：

monitorenter

执行monitorenter的线程尝试获得monitor锁的所有权，会发生如下三种情况之一：

a.如果monitor的计数为0，则该线程获得monitor时将其计数设置为1.然后这个线程就是该monitor的持有者

b.如果线程已经持有了monitor，则它将重新进入，并且计数累加

c.如果其它线程已经获取了这个monitor，那么这个线程就会被阻塞，直到这个monitor的计数变为0，代表这个monitor已经背时放了，于是当前线程就会尝试着再次获取这个monitor

monitorexit

monitorexit的作用就是将monitor的计数器减1，直到减到0为止。代表着这个monitor已经被释放了，已经没有线程拥有它了，也就代表着解锁，所以，其他正在等待这个 monitor 的线程，此时便可以再次尝试获取这个 monitor 的所有权。

<u>同步方法<u>

从上面可以看出，同步代码块是使用 monitorenter 和 monitorexit 指令实现的。而对于 synchronized 方法，并不是依靠 monitorenter 和 monitorexit 指令实现的，被 javap 反汇编后可以看到，synchronized 方法和普通方法大部分是一样的，不同在于，这个方法会有一个叫作 ACC_SYNCHRONIZED 的 flag 修饰符，来表明它是同步方法。

同步方法的代码如下所示。

```java
public synchronized void synMethod() {
 
}
```

对应的反汇编指令如下所示。

```java
{
  public Test();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0

  public synchronized void synBlock();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String 许楠，我爱你！
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 4: 0
        line 5: 8
}
```

可以看出，被synchronized修饰的方法会有一个ACC_SYNCHRONIZED标志。当某个线程需要访问某个方法时，回首先检查方法是否有ACC_SYNCHRONIZED标志，如果有则需要先获取monitor锁，然后才能执行方法，方法执行之后再释放monitor锁。其它的，synchronized方法和刚才的synchronized代码块类似，例如这时如果其他线程来请求执行方法，也会因为无法获得 monitor 锁而被阻塞。

小结

synchronized 代码块以及 synchronized 方法所对应的的反汇编指令，其中同步代码块是利用 monitorenter 和 monitorexit 指令实现的，而同步方法则是利用 flags 实现的。