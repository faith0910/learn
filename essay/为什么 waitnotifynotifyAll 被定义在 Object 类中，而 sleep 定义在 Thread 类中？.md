##### 为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？

1.因为在java中每个对象都会有一个monitor监视器锁，由于每个对象都可以上锁，所以在每个对象的对象头中存放着锁信息。锁又是针对对象级别，而非线程级别，wait/notify/notifyAll都是属于锁级别的操作，它们的锁属于对象，Object是一切对象的父类，所以定义在Object类中刚刚好。

2.把 wait/notify/notifyAll 定义在 Thread 类中，会带来很大局限性。比如一个线程会有很多把锁，以便实现相互配合的复杂逻辑。假设此时 wait 方法定义在 Thread 类中，如何实现让一个线程持有多把锁呢？又如何明确线程等待的是哪把锁呢？既然我们是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现，而不是操作线程。

##### wait/notify 和 sleep 方法的异同？

1.wait/notify是属于Object类的，而sleep属于Thread类的

2.wait方法必须在synchronized修饰的代码块中使用，而sleep没有做要求

3.wait会释放监视器锁，而sleep不会

4.sleep方法中回要求必须定义一个时间，时间到期之后会主动恢复，而对于没有参数的wait，则会永久等待，直到被中断，被唤醒，它并不会主动恢复。

##### 为何多线程的代码大部分都用while而不用if?

不管线程在哪被切换停止了，while的话，线程上次切换判断结果对下次切换判断没有影响，但是if的话，若线程切换前，条件成立过了，但是该线程再次拿到cpu使用权的时候，其实条件已经不成立了，所以不应该执行。（本质原因：就是原子性问题，CPU严重的原子性是针对CPU指令的，而不是针对高级编程语言的语句的）