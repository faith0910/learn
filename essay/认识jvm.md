#### JVM内存模型

​	JVM内存模型主要指运行时的数据区，包括五个部分，如图：

<img src="/Users/guanghui/Library/Application Support/typora-user-images/image-20200717190858232.png" alt="image-20200717190858232" style="zoom:50%;" />

A.程序计数器保存着当前线程所执行的字节码行号指示器（唯一一个没有OOM情况的区域），每个线程工作时都有一个独立的计数器，各条线程之间计数器互不影响，独立存储。程序计数器为执行java方法服务，程序计数器记录的是JVM字节码指令的地址；执行native方法时，程序计数器为空。

b.栈也叫方法栈，是线程私有的，线程在执行每个方法时都会同时创建一个栈帧，用来存储存储局部变量表（基本数据类型、对象引用和returnAddress）、操作数栈、动态连接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

c.本地方法栈与栈类似，也是用来保存线程执行方法时的信息，不同的是，执行java方法使用的是栈，执行native方法使用本地方法栈，与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。

d.堆是JVM管理内存中最大的一块，堆被所有线程共享，目地是为了存放对象实例，几乎所有的对象实例都在这里分配(由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换[优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了)。当堆内存没有可用空间时，会抛出OOM异常。根据对象的存活周期不同，JVM把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。

e.方法区也是各个线程共享的区域，由叫非堆区。用于储存虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据，JDK1.7中的永久代和JDK1.8中的Meataspace都是方法区的一种实现。

在 1.8 版本中对方法区进行调整，使用 Metaspace 替换掉了 PermGen 的永久代。Metaspace 与 PermGen 之间最大的区别在于：Metaspace 并不在虚拟机中，而是使用本地内存。替换的目的一方面是可以提升对元数据的管理同时提升 GC 效率，另一方面是方便后续 HotSpot 与 JRockit 合并。

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。  

##### JMM内存可见性

JMM是Java内存模型，JMM主要是定义程序中变量的访问规则（来屏蔽各种硬件和操作系统的内存访问差异，以实现让java在各种平台下都能达到一致内存访问效果。直到JDK5之后，内存模型变得成熟和完善起来，此处的变量包括实例字段、静态字段和构成数组对象的元素。如下图，所以共享变量都储存在主内存中共享。每个线程都有自己的工作内存，工作内存中保存的是主内存中变量的副本，线程对变量的读写都必须在自己的工作内存中进行，而不能直接读写主内存中的变量。

![](/Users/guanghui/Documents/32个Java面试必考点 - 新浪微博技术专家张雷 - 拉勾教育_files/CgotOV14lumATjNyAAB-0Ie_3x8688.png)

在多线程进行数据交互时，例如线程A给一个共享变量赋值后，由线程B来读取这个值，A修改完变量是在自己的工作内存中，B是不可见的，只有从A的工作区写回主内存，B再从主内存读取之后进行进一步操作。由于指令重排序的存在，这个写--读的顺序性有可能被打乱，因此JMM需要提供原子性、可见性、有序性的保证。

##### JMM保证

如图所示，来看JMM是如何保证原子性、可见性，有序性。

###### ![CgoB5l14lumAex05AAB83iBktjQ024](/Users/guanghui/Documents/32个Java面试必考点 - 新浪微博技术专家张雷 - 拉勾教育_files/CgoB5l14lumAex05AAB83iBktjQ024.png)**原子性**

JMM保证除对double和long外的基础数据类型的读写操作是原子性的。另外关键字synchronized也可以提供原子性保证。synchronized的原子性是通过java两个高级的字节码执行monitorenter和monitorexit来保证的。

###### 可见性

JMM 的可见性保证，一个是通过synchronized关键字，另一个就是volatile。volatile强制变量赋值会同步刷新回主内存，强制变量的读取会从主内存重新加载，保证不同线程总是会看到该变量的最新值。

###### 有序性

对有序性的保证，主要是通过volatile和一系列的happens-before原则。volatile的另一个作用就是阻止指令重排序，这样就可以保证变量读写的有序性。

happens-before原则包括一系列规则，如：
				程序顺序原则，即一个线程必须保证语义串行性；

​		锁规则，即对同一个锁的解锁一定发生在再次加锁之前；

​		happens-before原则的传递性、线程启动、中断、终止规则等。

##### 类加载机制

类的加载指的是将编译好的Class文件中的字节码读取到内存中，将其放在方法区内，并创建对应的Class对象。类的加载过程分为加载--链接--初始化，其中链接又包括验证、准备、解析三步。如图所示：

![](/Users/guanghui/Documents/32个Java面试必考点 - 新浪微博技术专家张雷 - 拉勾教育_files/CgotOV14lumAWI3bAACVhLcSULk171.png)

1.加载是文件到内存的过程。通过类的完全限定名查找该类的字节码文件，并利用字节码文件创建一个Class对象。

2.验证是对类的文件内容验证。目的在于确保Class文件符合当前虚拟机标准，不会危害虚拟机自身安全。主要包括四种：文件格式验证、元数据验证、字节马验证和符号引用验证。

3.准备阶段是进行分配内存。为类变量（static修饰的变量）分配内存，并且设置初始值。这里要注意，初始值是 0 或者 null，而不是代码中设置的具体值，代码中设置的值是在初始化阶段完成的。另外这里也不包括final修饰的静态变量，因为final变量在编译的时候就会分配。

4.解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。

5.初始化，主要完成静态块执行和静态变量的赋值。这是类加载的最后阶段，若被加载类的父类没有初始化，则先初始化父类。

如上图所示，浅绿的两个部分表示类的生命周期，就是从类的加载到类实例的创建与使用，再到类对象不再被使用时可以被 GC 卸载回收。这里要注意一点，由 Java 虚拟机自带的三种类加载器加载的类在虚拟机的整个生命周期中是不会被卸载的，只有用户自定义的类加载器所加载的类才可以被卸载。

##### 类加载器![](/Users/guanghui/Documents/32个Java面试必考点 - 新浪微博技术专家张雷 - 拉勾教育_files/CgoB5l14luqAA8NAAABwXhjZrug069.png)

如上图所示，Java 自带的三种类加载器分别是：BootStrap 启动类加载器、扩展类加载器和应用加载器（也叫系统加载器）。图右边的桔黄色文字表示各类加载器对应的加载目录。启动类加载器加载 java home 中 lib 目录下的类，扩展加载器负责加载 ext 目录下的类，应用加载器加载 classpath 指定目录下的类。除此之外，可以自定义类加载器。

java的类加载使用双亲委派模式，即一个类加载器在加载类时，先把这个请求委托给自己的父类加载器去执行，如果父加载器还存在父类加载器，就继续向上委托，直到顶层的启动类加载器，如上图中蓝色向上的箭头。如果父类能够完成类的加载，就成功返回，如果父类加载器无法完成加载，子类加载器才会尝试自己去加载。如图向下的橘黄色箭头。

优点：避免了类的重复加载，另外也避免了Java核心API被篡改。